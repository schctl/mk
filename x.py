#!/usr/bin/env python

"""
Helper script for building, installing, and testing `mk`.
"""

import os
import argparse
import hashlib

# Backwards compatibility
from typing import Any, Dict, List


# Constants

# Binary target
BIN = 'mk'

# Project root
DIR = os.path.dirname(os.path.abspath(__file__))

# Preseve original working dir
OLD = os.getcwd()

# Temporary build files
TMP = f'{DIR}/_tmp_build'

# Privilege giving binary
SUID = ''

# Feature requirements
FEATURES = {
    # --- Top level requirements ---
    '': {
        'headers': [],
        'dylibs': ['crypt']
    },
    # ------------------------------
    'sdw': {
        'headers': ['shadow'],
        'dylibs': []
    },
    'pam': {
        'headers': ['security/pam_appl'],
        'dylibs': ['pam']
    }
}


# Utilities

def su_copy(src: str, dest: str) -> int:
    return os.system(f'{SUID} cp -f {src} {dest}')


def setup_permissions(path: str):
    # ``.rws--x--x``
    os.system(f'{SUID} chown root {path}')
    os.system(f'{SUID} chmod 4755 {path}')


def test_cc(name: str, src: str, links: List[str]) -> str:
    # Check if the source compiles with ``c89``.

    path = os.path.join(TMP, f'{name.replace("/", "__")}.c')
    out = os.path.join(
        TMP, f'__build_{hashlib.md5(bytes(src, "utf-8")).hexdigest()}.out')

    # Don't recompile if we already have an output
    if os.path.exists(out):
        return out

    # Write source file
    with open(path, 'w') as f:
        f.write(src)

    cmd = f'c89 {path} {" ".join([f"-l{lib}" for lib in links])} -o {out}'

    print(f'Building source with command: \n\t{cmd}')

    # 0 expected
    if not os.system(cmd):
        return out

    return None


# Build and install related functions

def maybe_feature(feat: str) -> Dict[str, Any]:
    """Validate if a feature can be built."""

    # List of all requirements, walking down dependencies
    links = []
    headers = []
    defs = []

    if feat in FEATURES:
        # Get required libraries to link to
        if 'links' in FEATURES[feat]:
            links.extend(FEATURES[feat]['links'])

        # Get required header files to include
        if 'headers' in FEATURES[feat]:
            headers.extend(FEATURES[feat]['headers'])

        # Get required definitions
        if 'defs' in FEATURES[feat]:
            defs.extend(FEATURES[feat]['defs'])

        # Generate source file
        src = f"""
/* Autogenerated by ``mk/x.py`` */

#include <stdio.h>
{
    ' '.join(f'#include <{h}.h>' for h in headers)
}

int main(int argc, char** argv) {'{'}
{
    ''.join([(f'#ifndef {d[1::]}' if d.startswith('!') else f'#ifdef {d}') for d in defs])
}

    return 0;

{
    ' '.join(['#endif' for _ in defs])
}

    return -1;
{'}'}
"""

        if feat == '':
            feat = '__required_features__'

        print(f'Checking for feature ``{feat}`` ...')

        x = test_cc(feat, src, links)

        print(x)

        # 0 expected
        if not x or os.system(x):
            return None

    return {'links': links, 'headers': headers, 'defs': defs}


def cargo(cmd: str, *args, **kwargs) -> int:
    cmd = f'cargo {cmd} {" ".join(a for a in args)}'

    if 'features' in kwargs:
        cmd += f' --features "{" ".join(f for f in kwargs["features"])}"'

    print(f"Running command: \n\t{cmd}")

    return os.system(cmd)


def build(bin: str, rel: bool, feats: List[str]) -> str:
    print(f"Building ``{bin}`` with features: {feats} ...")

    if rel:
        cargo('build', '--release', features=feats)
    else:
        cargo('build', features=feats)

    return os.path.join('target', 'release' if rel else 'debug', bin)


def install(bin: str, feats: List[str]):
    su_copy(build(bin, True, feats), f'/usr/bin/{BIN}')
    setup_permissions(f'/usr/bin/{BIN}')
    print(f"Installed ``{bin}``")


# cli options

def setup() -> argparse.ArgumentParser:
    # Find privilege giving binary
    for i in ['/usr/bin/sudo', '/usr/bin/doas']:
        if os.path.exists(i):
            global SUID
            SUID = i
            break

    # Create temporary dir
    if not os.path.exists(TMP):
        os.makedirs(TMP)

    # Parse cli arguments
    parser = argparse.ArgumentParser(
        description="Build and install options for ``mk``.")
    parser.add_argument('--bin', nargs='?', type=str,
                        help="Name of the binary target to build.")
    parser.add_argument('--clean', action='store_true',
                        help="Clean build artifacts.")
    parser.add_argument('--test', action='store_true',
                        help="Test all crates in the workspace.")
    parser.add_argument('--build', nargs='?', const='debug',
                        type=str, help="Mode to build the binary in.")
    parser.add_argument('--install', action='store_true',
                        help="Install the binary to ``/usr/bin``.")
    parser.add_argument('--clippy', action='store_true',
                        help="Run ``cargo-clippy`` with specified features.")
    parser.add_argument('--features', nargs='?', const='', type=str,
                        help="Override default features to build the binary with, with no checks.")
    parser.add_argument('--perms', action='store_true',
                        help="Create a copy of the binary owned by the root user and with (generally) expected permissions.")

    return parser


def main():
    # Current binary target
    current_bin = BIN

    # Parse arguments
    args = setup().parse_args()

    # Collect available features
    features = []
    if not args.features or args.features == '':
        for f in FEATURES:
            if maybe_feature(f):
                features.append(f)
    else:
        features = args.features.split()

    if args.bin:
        current_bin = args.bin
    if args.clippy:
        cargo('clippy', features=features)
    if args.clean:
        cargo('clean')
    if args.test:
        cargo('test', '--workspace', features=features)
    if args.build:
        x = build(current_bin, args.build == 'release', features)
        if args.perms:
            su_copy(x, f'{DIR}/{BIN}')
            setup_permissions(f'{DIR}/{BIN}')
    if args.install:
        install(current_bin, features)


if __name__ == '__main__':
    # We'll operate in the project root for simplicity
    os.chdir(DIR)
    # Run the cli
    main()
    # Go back to the original working directory
    os.chdir(OLD)
